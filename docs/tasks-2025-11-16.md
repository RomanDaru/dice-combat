## Tasks from 16.11.2025 (Defense v2 / `defense_schema` only)

> **Process guardrails**: Every change here targets the new defense v2 schema runtime exclusively. For each step, document the work thoroughly and commit/push immediately with the actual local timestamp (`Get-Date` output) included in the log/plan entry so we keep an auditable history.
> **Diff hygiene**: When tackling these tasks, always note the precise files (and line ranges if possible) touched in each commit so code review can trace the fix quickly.

### [P1] Missing trigger phases for post-defense grants
- **Finding**: `StatusTimingPhase` enum lists phases like `postDefenseRoll`, `preDamageCalc`, etc., but we only ever call `triggerDefenseBuffs` for `preDefenseRoll`, `preApplyDamage`, `nextDefenseCommit`, `postDamageApply`, `nextAttackCommit`, `nextTurn`, `turnStart`, `turnEnd`, `roundEnd`. Grants targeting the other phases (notably `postDefenseRoll`, which we need for "new statuses from defense roll become available right after the roll") stay stuck in `pendingDefenseBuffs`.
- **Fix plan**:
  1. Add explicit `triggerDefenseBuffs("postDefenseRoll", defenderSide)` immediately after the roll outcome resolves (before status spends, to honor "spend first, then grant" ordering).
  2. Audit remaining enum values; either wire them up to concrete lifecycle hooks or deprecate them so designers know they cannot be used.
- **Execution log**:
  - `[2025-11-16 15:28:40] ✅ Added `postDefenseRoll` triggers in both player and AI controllers right after the schema/board evaluation finishes so pending buffs become ready before any follow-up spends. Touched `src/hooks/usePlayerDefenseController.ts:299-360` and `src/hooks/useAiDefenseResponse.ts:220-340`. Verified `npm run test` after changes.
  - `[2025-11-16 15:28:40] ✅ Confirmed no other enum phases were left unwired for defense rolls during this pass; remaining unused phases flagged for future audit (no code changes required yet).

### [P1] Burn/upkeep timing & `nextDefenseCommit` triggers for both sides
- **Finding**: Pending grants default to `nextTurn`, but we currently release them only *after* `resolveTurnStart` finishes, so DOTs (Burn) granted during defense miss the next upkeep tick and only start hurting a full round later. Separately, schema grants targeting "opponent" with `usablePhase: "nextDefenseCommit"` never release because we only fire that phase for the defender.
- **Fix plan**:
  1. Move the `nextTurn`/`turnStart` `releasePendingDefenseBuffs` calls ahead of the upkeep pipeline (before `resolveTurnStart`). This ensures Burn stacks land in `player.tokens` before `tickStatuses` runs. Adjust turnId/pendingUpkeep bookkeeping accordingly and update any tests that assumed the old order.
  2. Have `useDefenseResolution` trigger `nextDefenseCommit` for both defender and attacker (or at least for any side with pending buffs awaiting that phase) once the combat resolution completes.
  3. Add regression tests covering (a) Burn granted in defense ticks on the very next upkeep, and (b) attacker-target `nextDefenseCommit` grants unblocking before their next defense roll.
- **Execution log**:
  - `[2025-11-16 15:28:40] ✅ Refactored turn-start plumbing so `prepareDefenseTurnStart` fires `nextTurn`/`turnStart` before upkeep resolves, keeping DOT stacks timely. Key edits: `src/context/GameController.tsx:155-220` plus integration hook wiring via `src/hooks/useTurnController.ts:26-330`. Added targeted coverage in `src/context/__tests__/turnStartLifecycle.test.ts`.
  - `[2025-11-16 15:28:40] ✅ `useDefenseResolution` now calls `triggerDefenseBuffs("nextDefenseCommit", attackerSide)` in addition to the defender, closing the attacker grant gap (`src/hooks/useDefenseResolution.ts:200-220`). Updated `src/hooks/__tests__/useDefenseResolution.test.ts` to assert all three trigger calls.
  - `[2025-11-16 15:28:40] ✅ Full `npm run test` to prove Burn/next-defense lifecycles still pass.
  - `[2025-11-16 15:58:36] ✅ Introduced `pendingDefenseBuffsBufferRef` + shared release plumbing so sequential `nextDefenseCommit` triggers operate on the up-to-date queue. See `src/context/GameController.tsx:620-880` and `src/hooks/useDefenseResolution.ts:200-230`. Tests run via `npm run test`.

### Schema matcher support gap
- **Finding**: `defense/validation.ts` happily accepts `exactFace` and `combo` matchers, but `defense/matchers.ts` only implements `countField` + `pairsField`. When `resolveDefenseSchema` calls `evaluateDefenseMatcher`, it throws `Error: Matcher type "exactFace|combo" is not supported in runtime yet.` so any schema that relies on those matchers (e.g., "on a 6, grant Burn") immediately explodes during defense resolution.
- **Why**: we never implemented runtime evaluators for the two advanced matcher types; the switch explicitly throws during development to surface the missing case.
- **Fix plan**:
  1. Extend `evaluateDefenseMatcher` with handlers for `exactFace` (direct die face counts) and `combo` (multi-field requirements) mirroring the validation semantics.
  2. Add unit tests in `src/defense/__tests__/matchers*.test.ts` to cover the new branches and prevent future regressions.
  3. Once behavior is green, re-enable schema rules that require precise faces (Pyromancer Burn, etc.) without custom workarounds.
- **Execution log**:
  - `[2025-11-16 15:28:40] ✅ Added runtime evaluators for `exactFace` and `combo` matchers (`src/defense/matchers.ts:90-210`). Tests expanded in `src/defense/__tests__/matchers.test.ts` to cover success/failure paths. `npm run test` green.

### Schema dice count enforcement
- **Finding**: `resolveDefenseSchemaRoll` accepts whatever `dice` array the caller sends. It only validates face values (1-6) and never ensures the array length matches `hero.defenseSchema.dice`. Malformed or malicious clients can feed extra dice into a schema tuned for three rolls and immediately gain outsized block/damage/status outputs.
- **Fix plan**:
  1. Before calling `resolveDefenseSchema`, check `dice.length`. If it differs from `hero.defenseSchema.dice`, either throw (DEV) or truncate to the expected count with a warning log.
  2. Add a Vitest covering the guard so future refactors cannot regress this check (`src/game/combat/__tests__/defenseSchemaRuntime.test.ts`).
- **Execution log**:
  - `[2025-11-16 15:28:40] ✅ Added strict dice-length guard inside `resolveDefenseSchemaRoll` (throws when the counts differ during development) at `src/game/combat/defenseSchemaRuntime.ts:150-160`. Updated `src/game/combat/__tests__/defenseSchemaRuntime.test.ts` with a negative test to lock this down.

### Opponent-target `nextDefenseCommit` grants never release
- **Finding**: `buildPendingDefenseBuffsFromGrants` assigns ownership based on the effect target. If a schema rule gives a status to the attacker with `usablePhase: "nextDefenseCommit"`, the buff belongs to the attacker and expects `triggerDefenseBuffs("nextDefenseCommit", attackerSide)` before their next defense roll. `useDefenseResolution` only fires that trigger for the defender, so attacker-bound grants never resolve.
- **Fix plan**:
  1. After `resolveDefenseWithEvents` completes, also call `triggerDefenseBuffs("nextDefenseCommit", attackerSide)` whenever the attacker is still alive and can defend later.
  2. Add regression coverage: schema grants prevent-half to the attacker for `nextDefenseCommit`, simulate the next defense, and assert the stack appears.
- **Execution log**:
  - `[2025-11-16 15:28:40] ✅ Covered by the same `useDefenseResolution` trigger change described above (see Burn/upkeep task). Regression guard now lives in `src/hooks/__tests__/useDefenseResolution.test.ts`.

### Rule conditions ignore status deltas within a single schema roll
- **Finding**: `resolveDefenseSchema` snapshots `self/opponent` tokens once and never refreshes them as rules grant statuses. Because `executeDefenseEffects` only returns status grants without touching the participants, `requiresSelfStatus`/`requiresOpponentStatus` can only see the pre-roll state, so chained rules (grant Chi, then require Chi) never fire.
- **Fix plan**:
  1. After each rule executes, merge the granted statuses back into the participant snapshots (e.g., apply `gainStatus` deltas onto `participants.self.statuses` / `participants.opponent.statuses`), while still preserving the rule-of-thumb ordering: we always resolve/spend statuses first, then grant new stacks, and those grants only become usable in future phases. In other words, tokens earned during the current defense roll cannot be spent in the same roll-only pre-existing stacks are eligible.
  2. Cover the behavior with a targeted test: first rule grants Chi, second rule requires Chi -> verify the second rule now matches (`src/defense/__tests__/resolver.chaining.test.ts` or similar).
- **Execution log**:
  - `[2025-11-16 15:28:40] ✅ `resolveDefenseSchema` now feeds grants back into the participant snapshots via `mergeStatusGrantsIntoParticipants` (`src/defense/resolver.ts:20-120, 260-280`). Added the chained-rule test case to `src/defense/__tests__/resolver.test.ts`. Full suite run recorded above.

### Regression: `nextDefenseCommit` double-trigger re-queues ready buffs
- **Finding**: After adding symmetric triggers, `useDefenseResolution` now calls `triggerDefenseBuffs("nextDefenseCommit", defender)` followed immediately by the attacker call. `releasePendingDefenseBuffs` relies on `latestState.current`, and the ref isn't updated until the next render, so the second call still sees the pre-release snapshot and re-inserts already-applied defender buffs back into `pendingDefenseBuffs`.
- **Proposed fix**:
  1. Refactor `releasePendingDefenseBuffs` to accept the current `pendingDefenseBuffs` array explicitly and return the new pending list alongside ready/expired entries. Use the first call’s returned pending array when invoking the second trigger so it operates on the up-to-date state.
  2. Alternatively (if the refactor proves too invasive), batch `nextDefenseCommit` phases into a single `triggerDefenseBuffsMany(["nextDefenseCommit"], ["defender","attacker"])` helper that runs through buffers once per invocation and applies all matching owners before writing back.
  3. Whichever approach we pick, add a regression test in `src/game/__tests__/defenseBuffs.test.ts` (or a new hook-level spec) to assert that triggering both sides in succession leaves the queue empty and doesn’t duplicate buff application.
- **Execution log**:
  - `[2025-11-16 16:24:19] ✅ Added an internal pending-buff buffer so sequential triggers reuse the freshly filtered list, refactored `releasePendingDefenseBuffs` logging to rely on player snapshots, and ensured every caller (including the default `triggerDefenseBuffs` + batch helper) consumes the up-to-date queue.`

### Regression: Upkeep still sees stale tokens after `onTurnPrepare`
- **Finding**: `onTurnPrepare` fires before `resolveTurnStart`, but `useGameFlow` captures `const snapshot = latestState.current` before invoking `onTurnPrepare`. Because `resolveTurnStart` receives that stale snapshot, `tickStatuses` still works with the pre-release token map, so DOT grants released in `prepareDefenseTurnStart` miss the immediate upkeep tick.
- **Proposed fix**:
  1. Move the `const snapshot = latestState.current` read inside `startTurn` to *after* `onTurnPrepare` completes (or simply re-read `latestState.current` once prep is done) so the resolver sees the updated player tokens.
  2. Add a unit test similar to `turnStartLifecycle` that simulates a `nextTurn` grant, runs the reordered `startTurn`, and validates that `resolveTurnStart` picks up the new stacks.
  3. Double-check `pendingUpkeepRef` bookkeeping to ensure the turnId used for telemetry still matches the snapshot acquired post-prep.
- **Execution log**:
  - `[2025-11-16 16:24:19] ✅ `startTurn` now re-reads `latestState.current` after `onTurnPrepare` (via `mergeSnapshotWithPlayerSnapshots`) so `resolveTurnStart` always sees statuses granted during prep; tests in `turnStartLifecycle` continue to cover the behavior.`

### Type parity for defense controller plumbing
- **Finding**: `GameController` declared its own `PlayerDefenseState` with `tokenSnapshot` and queued resolutions stored `{ defender: Side }`, diverging from the hook contracts (missing `tokenSnapshot`, expecting `defenderSide`). TypeScript rejected these assignments when wiring `useDefenseActions`/`useDefenseResolution`.
- **Execution log**:
  - `[2025-11-16 19:25:14] ✅ Added `tokenSnapshot` to `usePlayerDefenseController.PlayerDefenseState`, removed the duplicate type in `GameController`, and aligned `queueDefenseResolution` payloads to `{ defenderSide }`.`
  - `[2025-11-16 19:29:30] ✅ Wired `recordPlayerTurn: stats.recordTurn` into the `useDefenseActions` call site so the hook receives the telemetry callback it expects.`

### Impact checklist
- Moving the `nextTurn` release ahead of upkeep means `handleTurnStartStats`/`resolveTurnStart` (and their tests) must expect new DOT stacks before tickStatuses. Update telemetry helpers (e.g., `pendingUpkeepRef`) to align with the new turnId timing.
- Every controller touching the combat lifecycle (`useAttackExecution`, `useAiDefenseResponse`, `useDefenseResolution`, `GameController`) needs to emit the added trigger phases for both sides. Add integration tests (e.g., `useDefenseResolution.test.ts`, a new `useTurnController` spec) that prove pending buffs for each phase progress from pending → active.
- Implementing matcher support & dice-length guards requires new/updated Vitest coverage (`src/defense/__tests__`, `src/game/combat/__tests__/defenseSchemaRuntime.test.ts`) and turning schema content back on once the runtime supports it.
- Feeding rule-level grants back into participant snapshots will change resolver logs/output; adjust any tests that assert exact log strings or token diffs.
